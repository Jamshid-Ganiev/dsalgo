{"/datastructure":{"title":"Ma'lumotlar Strukturasi","data":{"":"Agar siz \"Algoritm\" va \"Data Structure\"larni qanday tahlil (analysis) qilishni bilmasangiz, avval Big O notation bo'limini o'qib chiqishni maslahat beramiz!","data-structure-ozi-nima#Data Structure o'zi nima?":"Ma'lumotlar Strukturasi - bu ma'lumotlarga kirish va undan samarali foydalanish uchun tuziladigan ma'lumotlarni saqlash usuli desak bo'ladi. Uni konteynerga o'xshatsak bo'ladi. Turli konteynerlar turli xil usulda narsalarni ushlab turganidek ma'lumotlar strukturasi ham ma'lumotlarni biz aytgan uslubda ushlab tura oladi.Tasavvur qiling sayohatga chiqayabsiz.\n\nO'z chamadoningizga kerakli va muhim bo'lgan barcha narsani solishingiz kerak. Eng muhimi agar ulardan qaysidir birini unutsangiz, sayohat vaqti aniq qandaydir ko'ngilsizlikga uchraysiz. Nima qilasiz?\n\nYechim bor, check list tuzishingiz kerak!\n\nCheck list sizni ishingizni aniq yengillashtiradi va hech narsani unutmaganingizga ishonch beradi. Mana shu hayotiy misolda data structure aynan nima deb o'ylaysiz?Agar javobingiz Chamadon bo'lsa tabriklayman adashdingiz 😁. Agar Check List bo'lsa tabriklayman topdingiz. Nima uchun Check List bu yerdan Chamadon ham Data Structure ku deyishingiz aniq, ha ammo bizning muammoga yechim u emasda.Hayotdan juda ko'plab misollar keltirishimiz mumkin ammo keling qolganini sizga qoldirib sayohatimizni davom etamiz...","data-structures#Data Structures":"Biz sizga ketma-ket sayohat qilishingiz uchun manzillar tuzib qo'yganmiz. Ularni ketma-ket o'tish orqali siz ularni qanday kelib chiqishiyu, qachon ishlatish kerak kabi savollaringizga javob olasiz deb umid qilamiz.Agarda siz ro'yxatda keltirilgan barcha Data Structurelarni bilsangiz, sizni Algorithmlar mavzusidagi ajoyib qo'llanma kutib turibdi. Olg'a!"}},"/":{"title":"DSA.UZ","data":{"":"\"Ma'lumotlar strukturasi va Algoritmlar\" mavzusidagi tasavvurga boy va o'zbek tilidagi qo'llanma!","kirish#Kirish":"DWCE (Documentation With Code Exmpales) - Principle bo'yicha yozilgan ushbu qo'llanmada siz o'zingiz o'rganayotgan yoki biladigan dasturlash tilida Algoritmlar va Data Strukturalar qanday qo'llanilishini o'rganishingiz mumkinLoihani yozishda biz asosan 3ta \"princple\"ga amal qildik.\nWhat and Why? - X o'zi nimaligi va nima uchun kerakligi\nImagine - Xni qanday ishlashini illustratsiyalar bilan tushuntirish.\nHow - Xni dasturlash tilida kod orqali qanday ifoda qilish mumkinligi\n\nQo'llanmada ba'zi xatoliklarga yo'l qo'ygan bo'lishimiz mumkin. Shuni inobatga olib aytishim kerakki agarda xatolik topsangiz Issues bo'limida xatolik qayerdaligini aytib keting.Agar loihani qo'llab quvatlamoqchi bo'lsangiz, biz contribute uchun ochiqmiz va pull requestlarni loyiq deb topsak uni qabul qilamiz. Taklif va xatoliklarni Issues bo'limida New Issue orqali berib ketishingiz mumkin. Oldindan Rahmat 😊Unday bo'lsa boshladik 🚀!","dasturlash-tili#Dasturlash tili":"Qo'llanmani imkon boricha universal qilishga harakat qilayabmiz. Ushbu dokumentatsiyada Python dasturlash tili ishlatilgan. Siz o'zingizga qulay dasturlash tilini Tillar ro'yxatdan tanlashingiz mumkin.","mavzular#Mavzular":"Big O notation\nData Structures\nArrays\nLinked List\nStack and Queue\nGraph\nTree\nTrie\nHeap\nHash Table\nHash Table\n\n\nAlgorithms\nAlgorithmic Paradigms\nSorting\nSearching\nGraph Algorithms\nGreedy Algorithms\nDynamic Programming\nDivide and Conquer\n\n\n\nAgar sizda hech qanday DSA bo'yicha tajriba yoki ko'nikma bo'lmasa, mavzularni ketma-ketlikda o'rganishni tavsiya qilamiz. Agar sizda bu ko'nikmalar bo'lsa unda o'zingizga qulay mavzuni tanlab o'sha mavzudagi darslarimizdan foydalanishingiz mumkin."}},"/bigo":{"title":"Time Complexities","data":{"":"Algorithm - muammoni yechish uchun harakatlar ketma-ketligiga aytiladi.\n\nData Structure - ma'lumotlarni saqlash va tartibga solish uchun ishlatiladigan konteyner yoki saqlagich.\nComputer Scienceda biz ko'pincha algoritmlarning ishlashini tahlil qilishga qiziqamiz. Algoritm ishlash tezligini aniqlash uchun turli xil inputlar uchun algoritmimiz qancha vaqt sarflayotganini bilishimiz kerak. Misol uchun ro'yxatni tartiblaydigan algoritm yaratsak, u 10 ta raqam uchun qancha vaqt, 100 ta raqam uchun qancha vaqt, 1000 ta raqam  uchun qancha vaqt ketishini o'lchashimiz mumkin.Qachonki gap Algoritm tahlili haqida ketganda, bizga quyidagi ikki narsa doim qiziq bo'lishi lozim:\nTime - Qancha vaqt ketkazayabdi? (Nechta operatsiya bajaradi)\nMemory - Qancha xotira ketkazayabdi? (Qancha joy oladi)\n\nBilamizki hayotda o'lchovchi asboblar mavjud, masalan suvni o'lchash uchun litr yozilgan maxsus konteynerlardan foydalanamiz, uzunlikni o'lchash uchun sm yoki m o'lchamlari bor lineyka va ruletkalardan foydalanamiz. Ammo Algoritmlar uchun nimadan foydalanamiz?","big-o-notation---katta-o-belgisi#Big O notation - Katta O belgisi":"Big O notation Algoritmlarni tezligini o'lchash uchun ishlatiladigan asbob deb olsak bo'ladi. Algoritmga qanchalik katta hajmdagi ma'lumot kiritilsa u o'sha ma'lumot ustida bajaradigan operatsiyalar soni ham oshib boradi. Aynan shu orqali biz bilishimiz mumkinki, qancha xajmdagi ma'lumot uchun bizning algoritmimiz qancha vaqt va xotira talab qilishini.\nBig O notationni tushunish uchun Matematikaga biroz murojaat qilamiz. Chunki Dasturlashda Matematikani o'rni juda muhim!\nMatematikada funkisya degan tushuncha mavjud. Biz uni mana bu ko'rinishda ifodalashimiz mumkin.f(x) = x + 2{:py}Bu yerda biz f(x) dagi xga necha qiymatni bersak u o'sha qiymatni qavsdan keyingi ifodaga ham beradi degani misol uchun mana bunday:f(10) = 10 + 2{:py}Dasturlashga buni qanday dahli bor deyishingiz mumkin ammo shoshilmang endi yetib kelayabmiz. xga qancha katta qiymat bersak shuncha katta qiymat olayabmiz. Endi tasavvur qiling qiyinroq funksiyalarda bu ko'rsatgichlar qanchalik kattarishini. Endi algoritmlarni qanday o'lchashlikga o'tsak bo'ladi.Qachonki biz algoritmlarni tahlil qilganimizda, qancha kattalikdagi qiymatga nechta operatsiya bajarayabdi va qancha xotira talab qilayabdi degan savolni ilg'or suramiz.Tasavvur qiling, bizni algoritm berilgan arraydagi qiymatlardan faqat juft sonlarni yangi arrayga qo'shib, oxirida o'sha arrayni qaytarishi kerak.\ndef juftlar(arry : list[int]) -> list:\nresult = []\nfor num in arry:\nif num % 2 == 0:\nresult.append(num)\nreturn result\nYuqorida keltirilgan funksiyani oladigan bo'lsak biz qanchalik kattalikda array bersak u shunchalik ko'p operatsiya bajaradi. Misol uchun [1, 2, 3, 4, 5]{:py} ni bersak u 5ta sonni ham tekshiadi va ularni ichidan nechtasi juft bo'lsa uni yangi arrayga o'tkazadi. Agar array ichidagi elementlar soni 100ta bo'lsa 100ta operatsiya, n ta bo'lsa n ta operatsiya sodir qiladi.","time-complexity---vaqt-murakkabligi#Time Complexity - Vaqt murakkabligi":"Biz buni O(n){:py} ko'rinishda o'lchasak bo'ladi. Chunki qanchalik elementlar ko'p bo'lsa algoritm shunchalik ko'p operatsiya bajaradi. Ya'ni siz 100ta elementli array bersangiz funksiyadagi loop 100 marta iteratsiya qiladi, 1000 ta bersangiz 1000 marta iteratsiya qiladi. Har bir iteratsiya esa bu bitta operatisya (harakat) degani.\nBig O notation - algoritmni worst case xolati uchun ishlatiladi. Ya'ni worst case - eng yomon xolati deb tarjima qilsak bo'ladi.\nBiz bu tahlilga algoritmimiz eng yomon ko'rsatkichda ishlaganda n{:py} marta ishlaydi deb qarasak bo'ladi. Agarda sizning algoritmingiz O(n){:py} ko'rsatgichda bo'lsa dasturlashda uni Linear Time deb atashadi. Endi esa keling xotiraga ham to'xtalib o'tsak qanday qilib xotirani o'lchashimiz mumkin?","space-complexity#Space Complexity":"Biz xotira murakkabligini MB yoki GB larda o'lchamaymiz biz uni ham Big O notation orqali o'lchaymiz. Ammo qanday deyishingiz mumkin? Keling uni ham ko'rib chiqsak.Yuqoridagi kodni Time Complexitysi O(n){:py} bo'lgan bo'lsa Space Complexitysi ham O(n){:py} bo'layabdi. Ammo nimaga asoslanib, keling tushuntiraman.Bu yerda array hajmi oshgani sari biz qaytaradigan result nomli array hajmi ham oshib boradi. Agar biz 50ta juft sonlardan iborat array kiritsak u barcha elementlarni resultga qo'shishiga to'g'ri keladi chunki ularni 50tasi ham juft. Ya'ni aytib o'tganimdek Big O notation worst case holatini o'lchash uchun ishlatiladi.Agar biz 100ta element bor array bersak va arraydagi 50ta raqam juft, 50tasi esa toq sonlardan iborat bo'lsa bining ko'rsatgich O(n/2){:py} ko'rsatgichni beradi. Ammo foydalanuvchi qanday array berishi bizga noma'lumo bo'lgani uchun ham biz uni O(n){:py} deb olaveramiz. Demak bu narsaga tushundingiz deb umid qilaman.O'lchov birliklari juda ko'p. Ularni ba'zilarini hozir ushbu qo'llanma davomida o'rganishingiz mumkin, qolganlarini esa sayohatimiz va o'rganish paytida kashf qilib ketamiz.","constant-time---o1#Constant Time - O(1)":"Constant - o'zgarmas degan ma'noni anglatadi. Matematikada konstant qiymat nimada bor desa men pi ≈ 3.14159 ni ayta olaman. Biz constant qiymatni Big O da O(1){:py} deb o'lchaymiz. Nima uchun aynan 1 soni keltirilganini tushuntirishga menimcha xojat yo'q chunki qiymat birxil qolishi aytilayabdi. Kelin endi misol bilan ko'rsak\ndef access_element(arr : list, index : int) -> any:\nreturn arr[index]\nYuqorida keltirilgan kodda bizning access_element funksyamizga istalgan kattalikda input bermaylik u bu ishni qilishga bir xil vaqt sarflaydi. Ya'ni operatsiyalar soni bu yerda 1ta.\ndef sum_of_squares(n : int) -> int:\nreturn (n * (n + 1) * (2 * n + 1)) // 6\nBu ham huddi shunday istalgan xajmdagi qiymat bermaylik operatsiyalar soni oshmaydi ya'ni doim bitta operatsiya amalga oshiradi. Shuning uchun ham uni worst caseda O(1){:py} deb o'lchaymiz.","linear-time---on#Linear Time - O(n)":"Linear - Chiziqli degan ma'noni anglatadi. Tasavvur qiling oldingizda 100ta xona bor va har bir xona eshigida uning raqami bor. Xonalarni 99tasi bo'sha ammo bittasida xazina yashiringan. Siz esa o'sha xazinani topishingiz kerak. Xonalarni siz 1-eshikdan ochishni boshlaysiz keyin 2-eshik keyin 3-eshik va h.k.z.Eng ko'pi bilan siz 100ta xonani barchasini ochishingizga to'g'ri keladi. Ko'rib turibsizki omadingiz bo'lsa uni 1tada ham topishingiz mumkin. Agar unday bo'lmasa demak 100ta eshikni ham ochib ko'rasiz. Bir narsani yana eslatib o'taman biz Big O notation bilan faqat worst case holatini tahlil qilamiz. Kelin endi kod bilan ko'radigan bo'lsak.\ndef summing(numbers : list) -> int:\nresult = 0\nfor num in numbers:\nresult += num\nreturn result\nYuqoridagi kodda tasvirlanganidek biz result degan o'zgaruvchi ochib uni 0ga tenglashtirdik. Va keyin for loop orqali, funksiyaga beriladigan list qiymatini iteratsiya qilamiz. Iteratsiya har bir raqamni result o'zgaruvchisizga increment qilib borayabdi va oxirida esa uni qaytarayabdi.Demak bu yerda operatsiyalar soni bevosita funksiyaga beriladigan listning hajmiga bog'liq. Agar listda 23 ta element bo'lsa funksiyamiz 23 operatsiya bajaradi, agar 1 ta bo'lsa 1ta agar nta bo'lsa nta. Biz buni O(n){:py} deb o'lchadik!","quadratic-time---on2#Quadratic Time - O(n2)":"Quadratic - Kvadrat darajali degan ma'noni anglatadi. Tasavvur qiling ishxonada ho'jayiningiz sizga \"Xonani 2 marta tekshiring\" desa siz 4 marta tekshirasiz, \"4 marta tekshiring\" desa siz 16 marta tekshirasiz. Mana shu jarayon aynan quadratic deb atasak bo'ladi.\ndef numered_num(num : int) -> None:\nfor i in range(num):\nfor j in range(num):\nprint(f\"{i}.{j}\")\nYuqorida keltirilgan kodda nested-loop tasvirlangan. Biz funksiyaga necha qiymatni bersak u o'sha qiymatni kvadratichalik ko'p operatsiya bajaradi. Agar biz unga 2 ni kiritsak u 4 ta operatsiya qiladi, agar 5 ni kiritsak u 25 ta operatsiya bajaradi. Demak biz uni O(n2)Space Complexities","constant-space#Constant Space":"def summing(nums : list) -> int:\nresult = 0\nfor i in nums:\nresult += i\nreturn result\nYuqorida keltirilgan kodning space complexitysi O(1). Sababi bizning funksiyamiz 100 ta elementli listga ham 1 000 000 000 elementli listga ham bir xil ishlaydi. Operatsiyalar soni ko'p bo'lgani bilan biz barchasini faqat bitta result degan o'zgaruvchiga saqlayabmiz.\ndef sum_odds_evens(nums : list) -> str:\nodds = 0\nevens = 0\nfor i in nums:\nif i % 2 == 0:\nevens += i\nelse:\nodds += i\nreturn f\"odds = {odds}, evens = {evens}\"\nMana bu kodda ham Space Complexity O(1)ga teng. Chunki bizda funksiya boshlanishida ham tugashida ham faqat 2ta o'zgaruvchi qolayabdi. Ya'ni funksiyamiz yangi o'zgaruvchilar ochmayabdi, faqat bor o'zgaruvchilarni qiymati o'zgarayabdi. Demak agar funksiyangizdagi o'zgaruvchilar soni oshmasa.","linear-space#Linear Space":"def count_frequency(arr : list) -> dict:\nfreq_dict = {}\n\nfor elem in arr:\nif elem not in freq_dict:\nfreq_dict[elem] = 0\n\nfreq_dict[elem] += 1\n\nreturn freq_dict\nBu funksiya berilgan list ichida takrorlangan elementlar sonini sanaydi. Keling pastda qiymat berib ko'ramiz va berilgan qiymatga u qanday javob berishini Output orqali ifodalaymiz.\n# Input: [\"apple\", \"banana\", \"apple\", \"orange\", \"apple\"]\n\n# Output: {'apple': 3, 'banana': 1, 'orange': 1}\nYuqorida ko'rib turganingizdek array ichida takrorlanmaydigan so'zlar bo'lsa worst caseda bizning funksiyamizni Space Complexitysi O(n) ni tashkil qiladi. Agar omadimiz kelib takrorlanuvchi so'zlar bo'lsa n ta emas 1 ta ham bo'lishi mumkin.","quadratic-space#Quadratic Space":"def generate_pairs(arr : list) -> list:\npairs = []\n\nfor i in range(len(arr)):\nfor j in range(len(arr)):\npairs.append((arr[i], arr[j]))\n\nreturn pairs\nYuqoridagi funksiya list ichidagi har bir elementni sherik qilib pairs degan yangi listga qo'shib boradi.\n# Input: [1, 2, 3]\n\n# Output: [(3, 3), (3, 6), (3, 9), (6, 3), (6, 6), (6, 9), (9, 3), (9, 6), (9, 9)]\nKo'rib turibsizki listimiz hajmi qancha kattalashsa qaytariladigan qiymat soni ham uning kvadratiga teng bo'ladi. Yuqoridagi misolda bizning listimizda 3 ta element bor edi ammo funksiya qaytargan yangi list esa 9ta elementdan iborat bo'ldi. Shuning uchun ham biz uni O(n2) deb o'lchaymiz.Yana bir necha misolla keltirishimiz mumkin ammo qolganini sayohatimiz davomida o'rganib ketamiz. Hozircha shular edi."}}}