{"/languages/python":{"title":"Python","data":{"":"Bu yerda siz o'rganib borayotgan ma'lumotlar tuzilmalari va algoritmlarning Python dasturlash tilidagi kod implementatsiyasini\nko'rib o'rganib chiqsangiz bo'ladi. Biz imkon qadar kodlarni sizga tushuntirishga va sizni tasavvuringizni uyg'otishga harakat qilamiz.\nHar bir mavzuga tegishli kodlarni shu yerdan topishingiz mumkin. Agar sizga boshqa bir mavzu kerak bo'lsa o'ng tomondagi menu orqali\no'zingiz hohlagan mavzuga tez o'tishingiz mumkin.Har bir kodni ustida komment orqali u nima vazifa bajarishini yozib o'tishga harakat qilamiz. Uni o'zingiz ham sinab ko'rishni unutmang!","big-o#Big O":"Big O notationda o'rgangan bilimlaringizni keling endi amaliyotlarda misollar bilan ko'rib chiqamiz va biz odatiy yozadigan kodlarimizni\nanaliz qilishni o'rganamiz. Misol uchun pastdagi kodga e'tibor bering:\ndef juftlar(arry: list[int]) -> list:\nresult = []\nfor num in arry:\nif num % 2 == 0:\nresult.append(num)\nreturn result\nYuqoridagi kodning Time va Space Complexitysi nima deb o'ylaysiz? Keling tahlil qilamiz. Bu yerda for loop bor  demak bizni kodimiz\nlinear harakat qiladi ya'ni bu qandaydir shartlar asosida emas berilgan uzunlik asosida birma-bir iteratsiya bo'ladi. Shuning xisobiga\nko'ra bu n marta harakat qilayabdi. Ochilgan List esa har bir element uchun bitta xotira sarflaydi. Agar funksiyaga berilgan array\nichida faqat juft sonlar bo'lsa loop barcha listni iteratsiya qiladi. Biz shu tomonini ham o'ylagan holda uni ham n ta element oladi\ndeb xisoblaymiz.Time: O(n)Space : O(n)Keling endi keyingi misolga to'xtasak:\ndef access_element(arr: list, index : int) -> any:\nreturn arr[index]\nUshbu misolda bizning funksiya List olib uning berilgan indeksidagi elementni qaytarayabdi. Listlarda indeksga kirish uchun ketkaziladigan\nvaqt O(1) bo'ladi. Xotira esa bu yerda 1 chunki biz hech qanday yangi data type yaratmayabmiz. Demak xulosa:Time: O(1)Space : O(1)\ndef summing(numbers: list) -> int:\nresult = 0\nfor num in numbers:\nresult += num\nreturn result\nMana bu misolga qaraylik, bu yerda vaziyat biroz boshqacha endi biz result o'zgaruvchisini increment qilayabmiz. Ya'ni ortiqcha\no'zgaruvchilar ochmagan holda faqat result ustida amal qilib yana unga qiymat saqlayabmiz (shunchaki update qilayabmiz). Shuni\ninobatga olgan holda bu yerda space O(1) ga, time esa O(n) ga teng. Chunki bizning loop nta amal bajaradi eng ko'pi bilan.Bunday misollarni ko'plab keltirishimiz mumkin ammo keling endi qolganlarini yo'l-yo'lakay ko'rib tahlil qilib ketamiz...","array#Array":"Python dasturlash tilida Array degan built-in data structure mavjud emas ammo uning ekvivalenti bor u esa List.\nList - turli xil data typedagai ma'lumotlarni saqlab turuvchi konteyner xisoblanadi.\n\n# Pythonda List yaratish:\nmy_list = ['o', 'apple', 17, 3.14]\n\n# Bo'sh list yaratish:\nnew_list = list()\n\n# yoki\nnew_list = []","list-metodlari#List metodlari":"Yuqoridagi rasmda ba'zi metodlar keltirilgan ularni shunchaki ko'rib emas balkim ishlatib ko'rishni ham maslahat beraman. Agar siz ko'proq\nmetodlar haqida o'rganmoqchi bo'lsangiz Python dokumentatsiyasida ko'proq yoritib o'tilgan.","indexes#Indexes":"List ichidagi elementlarni access qilish ya'ni kirish uchun biz indexlardan foydalanamiz. Yuqoridagi rasmda ko'rib turganingizdek sanoq 1\ndan emas 0 dan boshlangan.\nXazil: Agar sizga biror dasturchi sen mening birinchi muhabbatimsan desa ishonmang. Chunki dasturlashda sanoq 0dan boshlanadi. ðŸ˜Œ\n\nnums = [3, 8, 1, 0, 5, -2, 32] # Rasmdagi list\n\nprint(nums[3]) # List ichidan 3chi indeksdagi qiymatni oldik.","slicing#Slicing":"Tasavvur qiling sizda 100ta elementli list bor ammo sizga uni faqat 20-50 ideks oralig'idagi qiymatlari kerak. Bunday holatda sizga\nlistdagi qiymatlarni o'chirish emas balkim shunchaki uni bo'laklarga bo'lish kifoya qiladi.\n\n\nlist[start:stop:step]\n# start - boshlang'ich nuqta\n# step - tugash nuqtasi\n# step - qadam\nls = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nls[2:]    # [3, 4, 5, 6, 7, 8, 9, 10]\nls[1:6]   # [2, 3, 4, 5, 6]\nls[:5]    # [1, 2, 3, 4, 5]\nls[1:4:2] # [2, 4]\nls[::2]   # [1, 3, 5, 7, 9]\nls[::-1]  # [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\nls[::-2]  # [10, 8, 6, 4, 2]\nYuqorida keltirilgan misollarni tushunishlik uchun ozgina tahlil qilib o'zingiz ham mashq qilib ko'ring.","python-array#Python Array":"Pythonda Array bor va uni yaratish uchun yoki tushunish uchun siz shunchaki array Python\nStandart Library ishlatishingiz kerak:\nfrom array import array\n\nnums = array('l', [1, 2, 3, 4, 5])\n\nnums.append(0) # array('l', [1, 2, 3, 4, 5, 0])\nnums.remove(3) # array('l', [1, 2, 4, 5, 0])\n...\n\nprint(nums[2]) # 4\n# Qolgan amallar xuddi listdek ishlatilaveradi. array yaratilishi boshqacha\nAmmo biz ushbu qo'llanmada bu kutubxonani to'liq ishlatmaymiz ammo sizga list va arrayni taqqoslab ular qanday ishlatilishini qisqacha ko'rsatib\no'tdik. Qolgan ma'lumotlarni link orqali o'zingiz o'rganishingiz mumkin.\nhttps://docs.python.org/3/library/array.html\nKeling endi ularni farqi nimadaligiga biroz chuqurroq kirishamiz. Pythonda hamma narsa object, xattoki funksiyalar ham. List esa juda moslashuvchan\nva ixtiyoriy ma'lumotlarni saqlashi mumkin, ammo ular Arrayga qaraganda ko'proq xotira ishlatadi. Pastdagi rasmga e'tibor bering:\n\nHar bir list pointer ichidagi pointer blokini xosil qiladi, natijada biz birinchi doim memory pointerga boramiz va undan keyin object\npointerga boramiz. Tushunarliroq qiladigan bo'lsak tasavvur qiling sizda my_list = [1, 2, 3, 4, 5] mavjud va siz my_list[2] ni olmoqchisiz.\nBu yerda python interpreter birinchi bo'lib my_listni xotirada qayerda joylashganini aniqlaydi. So'ngra my_listda 2chi indexni xisoblaydi va\nkeyin sizga siz hohlagan elementni qaytaradi.Arrayda esa xolat biroz boshqacha va keling yuqoridagi list misolini array qilib olamiz. Python interpreter my_list degan arrayni\nbirinchi qiymatini qidiradi. Va xotirani hozirgi hex qiymatiga biz hohlagan indeksni qo'shish orqali o'sha elementga oson kiradi.Listni afzalliklaridan ba'zilari bu uning kengayib, kichirayishida. List yana boshqa turdagi ma'lumotlarni ham saqlay oladi.Arrayning afzalliklaridan ba'zilari bu uning tezligida va listga nisbatan qaralganda ancha kam xotira sarflashida. Array faqat\nbir xil turdagi ma'lumotlarni o'zida saqlay oladi va uning xajmi o'zgarmaydi.","challenges#Challenges":"Merge Two sorted list\nFind two number that sums up to K","linked-list#Linked List":"Linked List pythonda built-in data structure sifatida kiritilmagan. Biz uni classlar yordamida yaratamiz chunki pythonda hamma narsa object.\nAgar siz Pythonda OOPni qanday ishlashini bilmasangiz, avval OOPni o'rganib chiqishingizni maslahat beramiz.","singly-linked-list#Singly Linked List":"Linked Listni turlicha usullar bilan implementatsiya qilishimiz mumkin. Bugun biz ba'zi keng tarqalgan yo'llarini ko'rib chiqamiz.\nclass Node:\ndef __init__(self, value: any) -> None:\nself.value = value\nself.next = None\n\nclass LinkedList:\ndef __init__(self) -> None:\nself.head = None\n\nmy_list = LinkedList()\nYuqoridagi misolda biz oddiy Singly Linked List yaratdik. U yerda siz 2ta class ko'rishingiz mumkin. Node classi odatda 2ta ma'lumotni\nushlab turish uchun kerak ya'ni data va next. LinkedList esa Node classlarni ushlab turadi. Ammo bizda muammo bor qanday qilib biz\nLinkedList classiga Nodelarni qo'shib boramiz?\n\nKeling endi LinkedList classidagi self.headga node qo'shish uchun method yaratamiz va uni nomini append deb qo'yamiz.\n# Biz self.head ga qiymat qo'shish uchun append yaratdik.\ndef append(self, value: any) -> None:\n# Birinchi bo'lib Node classidan yangi object yaratib olamiz.\nnew_node = Node(value)\n\n# Endi esa linkedlistimiz bo'sh emasligini tekshirishimiz kerak.\n# Buning uchun self.headni tekshirish kifoya. Agar u None bo'lsa linked list bo'sh degani.\nif self.head is None:\nself.head = new_node\nreturn\n\n# Agar linkedlistimizda nodelar bo'lsa, demak biz oxirgi nodeni topishimiz kerak.\n# Oxirgi nodeni topish uchun qaysi nodeni nexti None ekanligni aniqlashmiz kerak.\n# Buning uchun self.head dan boshlab oxirgi nodegacha iteratsiya qilamiz.\nlast_node = self.head\nwhile last_node.next:\nlast_node = last_node.next\n\n# Demak last_node oxirgi elementni topdi. Uni nexti hozircha None.\n# Yangi element esa uni nextiga tushishi kerak.\nlast_node.next = new_node\nYuqoridagi kodni kommentlarini o'qib chiqing va harakatlar ketma-ketligni tahlil qiling. Shunda jarayon yanada soddalashadi.\nKodni bir necha marta implementatsiya qilib ko'ring, bu esa sizga tajriba va tushunishingizni aniqlashtiradi. Keling endi boshqa methodlarini\nham yaratib chiqamiz.\nclass Node:\ndef __init__(self, value: any) -> None:\nself.value = value\nself.next = None\n\nclass LinkedList:\ndef __init__(self) -> None:\nself.head = None\n\ndef append(self, value: any) -> None:\nnew_node = Node(value)\nif self.head is None:\nself.head = new_node\nreturn\n\nlast_node = self.head\nwhile last_node.next:\nlast_node = last_node.next\nlast_node.next = new_node\n\n# Bu method berilgan qiymatni linkedlistni boshiga qo'shadi ya'ni headga.\ndef insert(self, value: any) -> None:\n# Avval linked listni tekshiramiz va head bo'lmasa headga qo'shamiz.\nnew_node = Node(value)\nif self.head is None:\nself.head = new_node\nreturn\n\n# Head bo'lsa demak yangi elementni nextini headga qaratamiz.\nnew_node.next = self.head\n# va new_node ni esa head deb tayinlaymiz.\nself.head = new_node\n\n\nmy_list = LinkedList()\nmy_list.append(1)\nmy_list.append(2)\nmy_list.append(3)\nmy_list.insert(0)\n\n# Buning ko'rinishi mana bunday: 0 -> 1 -> 2 -> 3 -> None\nprint(my_list.head.value)\nprint(my_list.head.next.value)\nprint(my_list.head.next.next.value)\nprint(my_list.head.next.next.next.value)\nprint(my_list.head.next.next.next.next)\nKeling boshqa methodlarini ham kiritib chiqsak va ularni keyin tahlil qilsak. Biz faqat methodni o'zini yozib ketamiz, siz esa uni\nclassingiz ichiga qo'shib, ishlatib va tahlil qilishingiz mumkin:\n# Bu method headni qaytarish uchun.\ndef get_head(self) -> any:\nreturn self.head\n\n\n# Linked List bo'shmi yo'qmi tekshirish uchun method\ndef is_empty(self) -> any:\nreturn self.head is None\n\n\n# Linked Listdagi barcha nodelarni bitta oddiy list qilib chiqarish uchun.\ndef print_list(self) -> None:\nresult = []\n# Agar head None bo'lsa [] qaytarsin.\nif self.head is None:\nreturn result\n# Agar unday bo'lmasa demak iteratsiya qilib har bir nodeni datasi listga qo'shadi.\ncurrent_node = self.head\nwhile current_node:\nresult.append(current_node.data)\ncurrent_node = current_node.next\nprint(result)\n\n\n# Biror qiymatni qidirish uchun ishlatiladi agar bo'lsa True bo'lmasa False qaytaradi.\ndef search(self, value: any) -> bool:\n# Agar Linked List bo'sh bo'lsa None qaytarishi kerak qidirmasdan.\nif self.head_node is None:\nreturn False\n# Agar qiymatlar bo'lsa, iteratsiya qilib ularni valuesi tekshiriladi.\ncurrent_node = self.head_node\nwhile current_node:\nif current_node.data == value:\nreturn True\ncurrent_node = current_node.next_element\nreturn False","doubly-linked-list#Doubly Linked List":"","circular-linked-list#Circular Linked List":""}}}